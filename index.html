<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>A2KDA Aurora</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #020617;
      --bg-elevated: #02081f;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.12);
      --good: #22c55e;
      --maybe: #eab308;
      --bad: #f97373;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --radius-lg: 18px;
      --radius-pill: 999px;
      --shadow-soft: 0 16px 40px rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 35%, #000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 1.5rem;
    }

    .app {
      width: 100%;
      max-width: 960px;
      background: radial-gradient(circle at 0 0, #020617 0, #020817 36%, #020617 60%);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      padding: 1.5rem 1.75rem 1.75rem;
      box-shadow: var(--shadow-soft);
      position: relative;
      overflow: hidden;
    }

    .aurora-glow {
      position: absolute;
      inset: -25%;
      background:
        radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.18), transparent 55%),
        radial-gradient(circle at 100% 0, rgba(52, 211, 153, 0.18), transparent 55%);
      opacity: 0.85;
      pointer-events: none;
      z-index: -1;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.2rem;
    }

    .title-block h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #e5f2ff;
    }

    .title-block p {
      margin: 0.15rem 0 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .pill {
      padding: 0.3rem 0.7rem;
      border-radius: var(--radius-pill);
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.45);
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--muted);
      white-space: nowrap;
    }

    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.25);
    }

    .card {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      border-radius: var(--radius-lg);
      padding: 1rem 1.1rem;
      border: 1px solid rgba(148, 163, 184, 0.28);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.85);
      position: relative;
      overflow: hidden;
    }

    .card + .card {
      margin-top: 0.8rem;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }

    .card-title {
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #cbd5f5;
    }

    .card-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .location-main {
      font-size: 1.02rem;
      font-weight: 500;
      margin-bottom: 0.15rem;
    }

    .location-detail {
      font-size: 0.88rem;
      color: var(--muted);
    }

    .location-meta {
      margin-top: 0.5rem;
      font-size: 0.78rem;
      color: var(--muted);
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .meta-pill {
      padding: 0.2rem 0.5rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.9);
    }

    .search-row {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.7rem;
    }

    .search-row input[type="text"] {
      flex: 1;
      padding: 0.45rem 0.6rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.98);
      color: var(--text);
      font-size: 0.86rem;
    }

    .search-row input[type="text"]::placeholder {
      color: #6b7280;
    }

    .btn {
      padding: 0.45rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.98);
      color: var(--text);
      font-size: 0.82rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .btn-primary {
      background: linear-gradient(to right, #22c55e, #38bdf8);
      border-color: transparent;
      color: #0b1120;
      font-weight: 500;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .lp-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.55rem;
      border-radius: var(--radius-pill);
      font-size: 0.78rem;
      border: 1px solid rgba(148, 163, 184, 0.32);
      background: rgba(15, 23, 42, 0.9);
      margin-top: 0.55rem;
      color: var(--muted);
    }

    .lp-indicator {
      width: 8px;
      height: 18px;
      border-radius: 999px;
      background: linear-gradient(to top, #ef4444, #facc15, #22c55e);
      position: relative;
      overflow: hidden;
    }

    .lp-indicator-inner {
      position: absolute;
      inset: auto 0 0 0;
      background: #020617;
      transition: height 0.3s ease;
    }

    .lp-badge-label-strong {
      font-weight: 500;
      color: #e5f2ff;
    }

    .lp-badge-dark {
      border-color: rgba(45, 212, 191, 0.7);
      background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.22), rgba(15, 23, 42, 0.96));
    }

    .lp-badge-suburban {
      border-color: rgba(250, 204, 21, 0.8);
      background: radial-gradient(circle at 0 0, rgba(250, 204, 21, 0.18), rgba(15, 23, 42, 0.96));
    }

    .lp-badge-urban {
      border-color: rgba(248, 113, 113, 0.85);
      background: radial-gradient(circle at 0 0, rgba(248, 113, 113, 0.2), rgba(15, 23, 42, 0.98));
    }

    .lp-badge-unknown {
      border-style: dashed;
    }

    .grid-two {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 0.9rem;
    }

    @media (max-width: 800px) {
      .grid-two {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-bottom: 0.4rem;
    }

    .slider-row label {
      font-size: 0.82rem;
      color: var(--muted);
      min-width: 2.5rem;
    }

    .slider-row input[type="range"] {
      flex: 1;
    }

    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 999px;
      background: #020617;
      outline: none;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0b1120;
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.3);
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0b1120;
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.3);
    }

    .kp-value {
      font-size: 0.82rem;
      padding: 0.15rem 0.55rem;
      border-radius: var(--radius-pill);
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.45);
      color: #e5f2ff;
    }

    .hint {
      font-size: 0.76rem;
      color: var(--muted);
      margin-top: 0.25rem;
    }

    .verdict {
      border-radius: var(--radius-lg);
      padding: 0.7rem 0.85rem;
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.18), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(56, 189, 248, 0.5);
      font-size: 0.9rem;
    }

    .verdict[data-state="yes"] {
      border-color: rgba(34, 197, 94, 0.7);
      background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.25), rgba(15, 23, 42, 0.98));
    }

    .verdict[data-state="maybe"] {
      border-color: rgba(250, 204, 21, 0.9);
      background: radial-gradient(circle at 0 0, rgba(250, 204, 21, 0.2), rgba(15, 23, 42, 0.98));
    }

    .verdict[data-state="no"] {
      border-color: rgba(248, 113, 113, 0.85);
      background: radial-gradient(circle at 0 0, rgba(248, 113, 113, 0.17), rgba(15, 23, 42, 0.98));
    }

    .verdict-main {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.7rem;
    }

    .verdict-text {
      font-weight: 500;
    }

    .verdict-score {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .debug-list {
      list-style: none;
      padding-left: 1rem;
      margin: 0.45rem 0 0;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .debug-list li {
      margin-bottom: 0.2rem;
      position: relative;
    }

    .debug-list li::before {
      content: "‚Ä¢";
      position: absolute;
      left: -0.75rem;
      color: rgba(148, 163, 184, 0.8);
    }

    /* Data status banner (old panel) */
    .status-banner {
      background: #fef9c3;
      color: #713f12;
      border-radius: var(--radius-lg);
      padding: 0.75rem 0.9rem;
      border: 1px solid #facc15;
      font-size: 0.85rem;
    }

    .status-banner-title {
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .status-banner ul {
      margin: 0.2rem 0 0;
      padding-left: 1.1rem;
    }

    .status-banner li {
      margin-bottom: 0.15rem;
    }

    /* Tonight summary + classic panels */

    .tonight-title {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #e5f2ff;
      margin-bottom: 0.35rem;
    }

    .tonight-location {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 0.6rem;
    }

    .tonight-chance {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.2rem;
    }

    .chance-low {
      color: #facc15;
    }

    .chance-medium {
      color: #22c55e;
    }

    .chance-high {
      color: #4ade80;
    }

    .tonight-direction {
      font-size: 0.92rem;
      margin-bottom: 0.35rem;
    }

    .tonight-geomag {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 0.55rem;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.3rem;
    }

    .chip {
      padding: 0.2rem 0.55rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148, 163, 184, 0.45);
      font-size: 0.78rem;
      background: rgba(15, 23, 42, 0.96);
    }

    .chip-label {
      font-weight: 500;
    }

    .chip-value {
      opacity: 0.9;
    }

    .hourly-bar {
      display: flex;
      gap: 0.6rem;
      margin-top: 0.4rem;
      overflow-x: auto;
      padding-bottom: 0.2rem;
      font-size: 0.78rem;
    }

    .hour-block {
      min-width: 44px;
      text-align: center;
      color: var(--muted);
    }

    .hour-block-time {
      margin-bottom: 0.15rem;
    }

    .hour-block-bar {
      width: 18px;
      height: 38px;
      border-radius: 999px;
      margin: 0 auto 0.15rem;
      background: linear-gradient(to top, #0f172a, rgba(56, 189, 248, 0.65));
      position: relative;
      overflow: hidden;
    }

    .hour-block-bar-inner {
      position: absolute;
      inset: auto 0 0 0;
      background: #020617;
    }

    .hour-block-meta {
      font-size: 0.7rem;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.8rem;
      margin-top: 0.8rem;
    }

    .detail-heading {
      font-size: 0.86rem;
      font-weight: 600;
      margin-bottom: 0.2rem;
    }

    .detail-body {
      font-size: 0.83rem;
      color: var(--muted);
    }

    .tip {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .tip strong {
      color: #e5f2ff;
      font-weight: 500;
    }

    .footer {
      margin-top: 1rem;
      font-size: 0.74rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 0.7rem;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="aurora-glow"></div>

    <header>
      <div class="title-block">
        <h1>A2KDA Aurora</h1>
        <p>See at-a-glance if there‚Äôs a realistic chance of aurora from where you are.</p>
      </div>
      <div class="pill">
        <span class="pill-dot"></span>
        <span>Live location &amp; sky brightness</span>
      </div>
    </header>

    <!-- LOCATION CARD (with search + light pollution badge) -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Location</div>
          <div class="card-subtitle">
            Used to estimate both aurora visibility and light pollution.
          </div>
        </div>
      </div>

      <div class="location-main" id="location-main">
        Working out where you are‚Ä¶
      </div>
      <div class="location-detail" id="location-detail">
        Waiting for your browser to share location, or falling back to an approximate IP-based lookup.
      </div>
      <div class="location-meta" id="location-meta">
        <span class="meta-pill" id="location-source-pill">Source: detecting‚Ä¶</span>
      </div>

      <div class="search-row">
        <input
          type="text"
          id="search-input"
          placeholder="Search place‚Ä¶"
          autocomplete="off"
        />
        <button class="btn" id="search-button">Search</button>
        <button class="btn btn-primary" id="gps-button">Use device GPS / IP</button>
      </div>

      <div
        class="lp-badge lp-badge-unknown"
        data-role="light-pollution-badge"
        title="Light pollution estimate will update once we have a location."
      >
        <div class="lp-indicator">
          <div class="lp-indicator-inner" style="height: 50%;"></div>
        </div>
        <span class="lp-badge-label-strong">Light pollution:</span>
        <span class="lp-badge-label">estimating‚Ä¶</span>
      </div>
    </section>

    <!-- DATA STATUS BANNER (classic panel) -->
    <section class="status-banner card" style="background:#fef9c3;color:#713f12;border-color:#facc15;">
      <div class="status-banner-title">Data status:</div>
      <ul>
        <li>Light pollution <strong>is included</strong> using a simple latitude-based model (can be replaced with a real data source).</li>
        <li>Moon altitude, detailed darkness and cloud data are still placeholders and not yet used in the main score.</li>
        <li>Your approximate location may be estimated from your internet connection if device GPS is not available.</li>
      </ul>
    </section>

    <!-- KP + VERDICT (new brain) -->
    <section class="grid-two">
      <section class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Aurora activity (KP)</div>
            <div class="card-subtitle">
              For now you can tweak KP manually to explore ‚Äúwhat if?‚Äù scenarios.
            </div>
          </div>
        </div>

        <div class="slider-row">
          <label for="kp-input">KP</label>
          <input type="range" id="kp-input" min="0" max="9" step="0.1" value="3.5" />
          <span class="kp-value" id="kp-value">KP 3.5</span>
        </div>
        <div class="hint">
          In the full app this will be driven by live space weather data (e.g. NOAA SWPC forecasts).
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Aurora visibility from here</div>
            <div class="card-subtitle">
              Takes into account KP, your distance from the auroral oval, sky brightness, and local time.
            </div>
          </div>
        </div>

        <div class="verdict" data-role="aurora-verdict" data-state="">
          <div class="verdict-main">
            <div class="verdict-text" id="verdict-text">
              Waiting for enough info to score your chances‚Ä¶
            </div>
            <div class="verdict-score" id="verdict-score">
              Score ‚Äî / 100
            </div>
          </div>
          <ul class="debug-list" data-role="aurora-debug">
            <li>We‚Äôll start as soon as we have a location and a KP value.</li>
          </ul>
        </div>
      </section>
    </section>

    <!-- TONIGHT SUMMARY (classic panel rebuilt) -->
    <section class="card">
      <div class="tonight-title" id="tonight-title">Tonight at your location</div>
      <div class="tonight-location" id="tonight-location-sub">Summary based on today‚Äôs conditions.</div>

      <div class="tonight-chance chance-low" id="tonight-chance">
        Low chance
      </div>
      <div class="tonight-direction" id="tonight-direction">
        Look North or North‚ÄìNorthwest.
      </div>
      <div class="tonight-geomag" id="tonight-geomag">
        Geomagnetic activity looks low; cloud and moonlight estimates are still placeholders.
      </div>

      <div class="chip-row">
        <div class="chip">
          <span class="chip-label">Aurora activity: </span>
          <span class="chip-value" id="chip-aurora">Low</span>
        </div>
        <div class="chip">
          <span class="chip-label">Clouds: </span>
          <span class="chip-value" id="chip-clouds">Mostly clear (placeholder 20%).</span>
        </div>
        <div class="chip">
          <span class="chip-label">Moon: </span>
          <span class="chip-value" id="chip-moon">Moon phase shown per hour; altitude integration coming soon.</span>
        </div>
        <div class="chip">
          <span class="chip-label">Darkness: </span>
          <span class="chip-value" id="chip-darkness">Sunset / sunrise times placeholder.</span>
        </div>
        <div class="chip">
          <span class="chip-label">Light pollution: </span>
          <span class="chip-value" id="chip-lightpollution">Included via latitude-based model.</span>
        </div>
      </div>
    </section>

    <!-- NEXT DARK HOURS PLACEHOLDER -->
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Next dark hours</div>
          <div class="card-subtitle">
            Prototype bar chart ‚Äì viewing chance, cloud cover and moon phase will plug in here.
          </div>
        </div>
      </div>

      <div class="hourly-bar" id="hourly-bar">
        <!-- Simple fixed demo hours -->
        <div class="hour-block">
          <div class="hour-block-time">16:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 70%;"></div>
          </div>
          <div class="hour-block-meta">61% ¬∑ üåñ</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">17:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 55%;"></div>
          </div>
          <div class="hour-block-meta">31% ¬∑ üåñ</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">18:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 60%;"></div>
          </div>
          <div class="hour-block-meta">39% ¬∑ üåñ</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">19:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 85%;"></div>
          </div>
          <div class="hour-block-meta">12% ¬∑ üåó</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">20:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 95%;"></div>
          </div>
          <div class="hour-block-meta">2% ¬∑ üåó</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">21:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 100%;"></div>
          </div>
          <div class="hour-block-meta">0% ¬∑ üåó</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">22:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 92%;"></div>
          </div>
          <div class="hour-block-meta">4% ¬∑ üåò</div>
        </div>
        <div class="hour-block">
          <div class="hour-block-time">23:00</div>
          <div class="hour-block-bar">
            <div class="hour-block-bar-inner" style="height: 80%;"></div>
          </div>
          <div class="hour-block-meta">9% ¬∑ üåò</div>
        </div>
      </div>
    </section>

    <!-- DETAIL CARDS -->
    <section class="detail-grid">
      <div class="card">
        <div class="detail-heading">Aurora activity</div>
        <div class="detail-body" id="detail-aurora">
          KP and geomagnetic latitude combine into an overall activity level. This is currently driven by your chosen KP slider value.
        </div>
      </div>
      <div class="card">
        <div class="detail-heading">Clouds</div>
        <div class="detail-body" id="detail-clouds">
          Cloud cover will eventually be pulled from a weather API. For now we assume ‚Äúmostly clear (20%)‚Äù as a placeholder for testing layouts.
        </div>
      </div>
      <div class="card">
        <div class="detail-heading">Moon</div>
        <div class="detail-body" id="detail-moon">
          Moon phase and altitude will affect how washed-out the sky is. The hourly strip above is a rough mock; detailed modelling to follow.
        </div>
      </div>
      <div class="card">
        <div class="detail-heading">Darkness</div>
        <div class="detail-body" id="detail-darkness">
          Civil, nautical and astronomical twilight, plus sunset/sunrise, will be used to define the ‚Äúdark window‚Äù. At the moment this panel is descriptive only.
        </div>
      </div>
      <div class="card">
        <div class="detail-heading">Light pollution</div>
        <div class="detail-body" id="detail-lightpollution">
          We estimate light pollution from your latitude/longitude as a simple heuristic. Later, this can be swapped for a proper sky brightness / Bortle data source.
        </div>
      </div>
    </section>

    <!-- TIP -->
    <section class="card">
      <div class="tip">
        <strong>Tip:</strong> Give your eyes 20‚Äì30 minutes to adjust to the dark and avoid bright white
        screens while watching for aurora.
      </div>
    </section>

    <div class="footer">
      <span id="footer-time"></span>
      <span>Light pollution is currently estimated with a simple latitude-based model. You can plug in a real data source later.</span>
    </div>
  </div>

  <!-- LIGHT POLLUTION MODULE -->
  <script>
    (function (global) {
      "use strict";

      function normalizeLightPollution(options) {
        const opts = options || {};
        const bortle = typeof opts.bortle === "number" ? opts.bortle : null;
        const skyBrightness =
          typeof opts.skyBrightness === "number" ? opts.skyBrightness : null;

        if (bortle != null) {
          const clamped = Math.min(9, Math.max(1, bortle));
          return (clamped - 1) / 8;
        }

        if (skyBrightness != null) {
          const min = 18;
          const max = 21.5;
          const v = Math.min(max, Math.max(min, skyBrightness));
          const norm = 1 - (v - min) / (max - min);
          return norm;
        }

        return 0.5;
      }

      function classifyLightPollutionValue(normalized) {
        const n = Math.min(1, Math.max(0, normalized));
        if (n < 0.33) {
          return { label: "Dark skies", code: "dark" };
        } else if (n < 0.66) {
          return { label: "Suburban skies", code: "suburban" };
        } else {
          return { label: "Urban / bright skies", code: "urban" };
        }
      }

      async function getLightPollution(lat, lon) {
        let heuristicNorm = 0.5;

        if (typeof lat === "number" && typeof lon === "number") {
          const absLat = Math.abs(lat);
          if (absLat > 66) {
            heuristicNorm = 0.22;
          } else if (absLat > 58) {
            heuristicNorm = 0.32;
          } else if (absLat > 50) {
            heuristicNorm = 0.42;
          } else if (absLat > 40) {
            heuristicNorm = 0.58;
          } else {
            heuristicNorm = 0.72;
          }

          const absLon = Math.abs(lon);
          if (absLon > 150 || absLon < 20) {
            heuristicNorm -= 0.05;
          }
        }

        const normalized = Math.min(1, Math.max(0, heuristicNorm));
        const classification = classifyLightPollutionValue(normalized);

        return {
          source: "fallback",
          normalized,
          classification,
          bortleClass: undefined,
          skyBrightness: undefined
        };
      }

      global.LightPollution = {
        normalizeLightPollution,
        classifyLightPollutionValue,
        getLightPollution
      };
    })(window);
  </script>

  <!-- AURORA BRAIN MODULE -->
  <script>
    (function (global) {
      "use strict";

      function kpScore(kp) {
        const k = Math.min(9, Math.max(0, Number(kp) || 0));
        return (k / 9) * 60;
      }

      function locationScore(distanceToOvalKm) {
        const maxDist = 1500;
        const d = Math.min(maxDist, Math.max(0, Number(distanceToOvalKm) || 0));
        return 30 * (1 - d / maxDist);
      }

      function lightPollutionPenalty(lightPollution, kp) {
        const lp = Math.min(1, Math.max(0, Number(lightPollution) || 0));
        const basePenalty = 30 * lp;

        const k = Math.min(9, Math.max(0, Number(kp) || 0));
        const kpReliefFactor = Math.min(1, k / 7);
        const effectivePenalty = basePenalty * (1 - kpReliefFactor * 0.7);

        return effectivePenalty;
      }

      function timeOfNightAdjustment(timeLocalHour) {
        if (typeof timeLocalHour !== "number") return 0;
        const h = ((timeLocalHour % 24) + 24) % 24;

        if (h >= 22 || h < 2) return +5;
        if ((h >= 3 && h <= 4) || (h >= 20 && h <= 21)) return +2;
        if (h >= 9 && h <= 17) return -10;
        return 0;
      }

      function computeBrain(inputs) {
        const {
          kp,
          distanceToOvalKm,
          geomagneticLatitude,
          lightPollution,
          cloudCover,
          timeLocalHour
        } = inputs;

        const debug = [];

        const sKp = kpScore(kp);
        debug.push(`KP index ${kp} contributes ${sKp.toFixed(1)} points.`);

        const sLoc = locationScore(distanceToOvalKm);
        debug.push(
          `Your position relative to the auroral oval contributes ${sLoc.toFixed(
            1
          )} points.`
        );

        const lpPenalty = lightPollutionPenalty(lightPollution, kp);
        if (lightPollution < 0.33) {
          debug.push(
            `Dark skies ‚Äì only a small light pollution penalty (${lpPenalty.toFixed(
              1
            )} points).`
          );
        } else if (lightPollution < 0.66) {
          debug.push(
            `Moderate light pollution ‚Äì medium penalty (${lpPenalty.toFixed(
              1
            )} points).`
          );
        } else {
          debug.push(
            `Bright urban skies ‚Äì heavy light pollution penalty (${lpPenalty.toFixed(
              1
            )} points).`
          );
        }

        let score = sKp + sLoc - lpPenalty;

        if (typeof cloudCover === "number") {
          const cc = Math.min(1, Math.max(0, cloudCover));
          const cloudPenalty = 25 * cc;
          score -= cloudPenalty;
          debug.push(
            `Cloud cover reduces the score by ${cloudPenalty.toFixed(
              1
            )} points (cover: ${(cc * 100).toFixed(0)}%).`
          );
        }

        const timeAdj = timeOfNightAdjustment(timeLocalHour);
        if (timeAdj !== 0) {
          score += timeAdj;
          debug.push(
            `Local time adjustment of ${timeAdj.toFixed(
              1
            )} points based on ${timeLocalHour}:00.`
          );
        }

        score = Math.max(0, Math.min(100, score));

        let verdict;
        if (score >= 65) {
          verdict = "yes";
        } else if (score >= 35) {
          verdict = "maybe";
        } else {
          verdict = "no";
        }

        debug.push(
          `Final visibility score is ${score.toFixed(
            0
          )} / 100 ‚Üí verdict: ${verdict.toUpperCase()}.`
        );

        return {
          score,
          verdict,
          debug,
          kpScore: sKp,
          locationScore: sLoc,
          lightPollutionPenalty: lpPenalty,
          geomagneticLatitude
        };
      }

      global.AuroraBrain = {
        kpScore,
        locationScore,
        lightPollutionPenalty,
        timeOfNightAdjustment,
        computeBrain
      };
    })(window);
  </script>

  <!-- APP WIRING -->
  <script>
    (function () {
      "use strict";

      const locMainEl = document.getElementById("location-main");
      const locDetailEl = document.getElementById("location-detail");
      const locMetaEl = document.getElementById("location-meta");
      const lpBadgeEl = document.querySelector("[data-role='light-pollution-badge']");
      const lpIndicatorInner = lpBadgeEl.querySelector(".lp-indicator-inner");
      const kpInputEl = document.getElementById("kp-input");
      const kpValueEl = document.getElementById("kp-value");
      const verdictContainer = document.querySelector("[data-role='aurora-verdict']");
      const verdictTextEl = document.getElementById("verdict-text");
      const verdictScoreEl = document.getElementById("verdict-score");
      const debugListEl = document.querySelector("[data-role='aurora-debug']");
      const footerTimeEl = document.getElementById("footer-time");
      const searchInputEl = document.getElementById("search-input");
      const searchButtonEl = document.getElementById("search-button");
      const gpsButtonEl = document.getElementById("gps-button");

      // Tonight + classic panels
      const tonightTitleEl = document.getElementById("tonight-title");
      const tonightLocationSubEl = document.getElementById("tonight-location-sub");
      const tonightChanceEl = document.getElementById("tonight-chance");
      const tonightGeomagEl = document.getElementById("tonight-geomag");
      const chipAuroraEl = document.getElementById("chip-aurora");

      const state = {
        lat: null,
        lon: null,
        geomagneticLatitude: null,
        distanceToOvalKm: null,
        lightPollution: 0.5,
        kp: parseFloat(kpInputEl.value) || 3.5,
        cloudCover: null,
        locationShort: "your location",
        usingIp: false
      };

      function updateFooterTime() {
        const now = new Date();
        const timeStr = now.toLocaleString(undefined, {
          weekday: "short",
          hour: "2-digit",
          minute: "2-digit"
        });
        footerTimeEl.textContent = `Local time detected as ${timeStr}.`;
      }

      function approxGeomagneticLatitude(lat) {
        if (typeof lat !== "number") return null;
        return lat - 11; // simple approximation
      }

      function approxDistanceToOvalKm(geomagLat) {
        if (typeof geomagLat !== "number") return null;
        const ovalLat = 67;
        const deltaLat = Math.abs(geomagLat - ovalLat);
        return deltaLat * 111;
      }

      function setLocationDisplay(options) {
        const {
          labelMain,
          labelDetail,
          sourceLabel,
          sourceKind,
          coordsText,
          shortLabel
        } = options;

        if (labelMain) locMainEl.textContent = labelMain;
        if (labelDetail) locDetailEl.textContent = labelDetail;

        state.locationShort = shortLabel || labelMain || "your location";

        locMetaEl.innerHTML = "";

        const src = document.createElement("span");
        src.className = "meta-pill";
        src.textContent = `Source: ${sourceLabel}`;
        locMetaEl.appendChild(src);

        if (coordsText) {
          const coords = document.createElement("span");
          coords.className = "meta-pill";
          coords.textContent = coordsText;
          locMetaEl.appendChild(coords);
        }

        if (sourceKind === "ip") {
          src.style.borderColor = "rgba(234,179,8,0.9)";
        } else if (sourceKind === "gps") {
          src.style.borderColor = "rgba(34,197,94,0.9)";
        } else if (sourceKind === "search") {
          src.style.borderColor = "rgba(56,189,248,0.9)";
        }

        // Update tonight header
        tonightTitleEl.textContent = `Tonight at ${state.locationShort}`;
        tonightLocationSubEl.textContent = "Tonight‚Äôs view based on current KP and a simple sky model.";
      }

      function renderLightPollutionBadge(lpResult) {
        if (!lpBadgeEl) return;

        if (!lpResult) {
          lpBadgeEl.className = "lp-badge lp-badge-unknown";
          lpBadgeEl.title =
            "Light pollution estimate is unavailable ‚Äì using a default middle-of-the-road value.";
          lpBadgeEl.querySelector(".lp-badge-label-strong").textContent =
            "Light pollution:";
          lpBadgeEl.querySelector(".lp-badge-label").textContent = "unknown";
          lpIndicatorInner.style.height = "50%";
          return;
        }

        const { normalized, classification } = lpResult;
        lpBadgeEl.className = `lp-badge lp-badge-${classification.code}`;
        lpBadgeEl.querySelector(".lp-badge-label-strong").textContent =
          "Light pollution:";
        lpBadgeEl.querySelector(".lp-badge-label").textContent =
          classification.label;
        lpBadgeEl.title = `Normalized light pollution: ${(
          normalized * 100
        ).toFixed(0)} / 100 (0 = dark, 100 = very bright)`;

        const darkHeight = 10;
        const brightHeight = 90;
        const height = darkHeight + (brightHeight - darkHeight) * normalized;
        lpIndicatorInner.style.height = `${height}%`;
      }

      function updateTonightSummary(result) {
        // chance text
        let label = "Low chance";
        let cls = "chance-low";

        if (result.verdict === "yes") {
          label = "Good chance";
          cls = "chance-high";
        } else if (result.verdict === "maybe") {
          label = "Low to moderate chance";
          cls = "chance-medium";
        }

        tonightChanceEl.textContent = label;
        tonightChanceEl.className = `tonight-chance ${cls}`;

        const kp = state.kp;
        let activityText = "Low";
        if (kp >= 7) activityText = "Very high";
        else if (kp >= 5) activityText = "High";
        else if (kp >= 3.5) activityText = "Moderate";

        chipAuroraEl.textContent = activityText;

        tonightGeomagEl.textContent =
          `KP index ${kp.toFixed(1)} with your latitude gives a ` +
          `${activityText.toLowerCase()} level of geomagnetic activity; ` +
          `clouds and moonlight are still placeholders here.`;
      }

      function renderAuroraVerdict(result) {
        const { verdict, score, debug } = result;

        verdictContainer.dataset.state = verdict;

        if (verdict === "yes") {
          verdictTextEl.textContent =
            "Conditions look good ‚Äì you have a solid chance of seeing aurora from here. üåå";
        } else if (verdict === "maybe") {
          verdictTextEl.textContent =
            "It‚Äôs possible, but conditions are borderline. A darker spot or higher KP would really help.";
        } else {
          verdictTextEl.textContent =
            "It‚Äôs unlikely right now. You‚Äôd need much stronger activity or darker skies.";
        }

        verdictScoreEl.textContent = `Score ${score.toFixed(0)} / 100`;

        if (debugListEl) {
          debugListEl.innerHTML = "";
          debug.forEach((line) => {
            const li = document.createElement("li");
            li.textContent = line;
            debugListEl.appendChild(li);
          });
        }

        updateTonightSummary(result);
      }

      function recomputeAurora() {
        if (state.lat == null || state.lon == null) {
          verdictTextEl.textContent =
            "We‚Äôre still waiting for a location before we can score your chances.";
          verdictScoreEl.textContent = "Score ‚Äî / 100";
          verdictContainer.dataset.state = "";
          return;
        }

        const now = new Date();
        const localHour = now.getHours();

        const geomagLat =
          state.geomagneticLatitude != null
            ? state.geomagneticLatitude
            : approxGeomagneticLatitude(state.lat);
        const distanceKm =
          state.distanceToOvalKm != null
            ? state.distanceToOvalKm
            : approxDistanceToOvalKm(geomagLat);

        state.geomagneticLatitude = geomagLat;
        state.distanceToOvalKm = distanceKm;

        const result = window.AuroraBrain.computeBrain({
          kp: state.kp,
          distanceToOvalKm: distanceKm,
          geomagneticLatitude: geomagLat,
          lightPollution: state.lightPollution,
          cloudCover: state.cloudCover,
          timeLocalHour: localHour
        });

        renderAuroraVerdict(result);
      }

      function onKpChange() {
        const val = parseFloat(kpInputEl.value) || 0;
        state.kp = val;
        kpValueEl.textContent = `KP ${val.toFixed(1)}`;
        recomputeAurora();
      }

      async function updateLightPollution(lat, lon) {
        try {
          const result = await window.LightPollution.getLightPollution(lat, lon);
          state.lightPollution = result.normalized;
          renderLightPollutionBadge(result);
          recomputeAurora();
        } catch (err) {
          console.error("Failed to estimate light pollution", err);
          state.lightPollution = 0.5;
          renderLightPollutionBadge(null);
          recomputeAurora();
        }
      }

      function useIpLocationFallback() {
        fetch("https://ipapi.co/json/")
          .then((res) => res.json())
          .then((data) => {
            const city = data.city || "your area";
            const country = data.country_name || data.country || "your country";
            const lat = typeof data.latitude === "number" ? data.latitude : data.lat;
            const lon =
              typeof data.longitude === "number" ? data.longitude : data.lon;

            state.lat = typeof lat === "number" ? lat : null;
            state.lon = typeof lon === "number" ? lon : null;

            const coordsText =
              state.lat != null && state.lon != null
                ? `Approx. ${state.lat.toFixed(2)}¬∞, ${state.lon.toFixed(2)}¬∞`
                : null;

            setLocationDisplay({
              labelMain: `Near ${city} \u2022 ${country}`,
              labelDetail: "Location estimated from your network (IP).",
              sourceLabel: "IP-based (approximate)",
              sourceKind: "ip",
              coordsText,
              shortLabel: `Near ${city}`
            });

            if (state.lat != null && state.lon != null) {
              updateLightPollution(state.lat, state.lon);
            } else {
              recomputeAurora();
            }
          })
          .catch((err) => {
            console.error("IP location failed", err);
            setLocationDisplay({
              labelMain: "Couldn‚Äôt determine your location.",
              labelDetail:
                "We couldn‚Äôt get GPS or IP information. Try refreshing or checking location permissions.",
              sourceLabel: "Unavailable",
              sourceKind: "unknown",
              coordsText: null
            });
            renderLightPollutionBadge(null);
            recomputeAurora();
          });
      }

      function initLocationViaGps() {
        if (!navigator.geolocation) {
          useIpLocationFallback();
          return;
        }

        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude, accuracy } = pos.coords;
            state.lat = latitude;
            state.lon = longitude;

            const coordsText = `${latitude.toFixed(3)}¬∞, ${longitude.toFixed(
              3
            )}¬∞ (¬±${Math.round(accuracy)} m)`;

            setLocationDisplay({
              labelMain: "Location from your device",
              labelDetail:
                "Using your device‚Äôs location services. This is typically accurate to a few hundred metres.",
              sourceLabel: "Device location (precise)",
              sourceKind: "gps",
              coordsText,
              shortLabel: "Your device location"
            });

            updateLightPollution(latitude, longitude);
          },
          (err) => {
            console.warn("Geolocation failed, falling back to IP", err);
            useIpLocationFallback();
          },
          {
            enableHighAccuracy: true,
            timeout: 8000,
            maximumAge: 600000
          }
        );
      }

      function geocodeSearch(query) {
        const url =
          "https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=" +
          encodeURIComponent(query);

        searchButtonEl.disabled = true;
        fetch(url, { headers: { "Accept-Language": "en" } })
          .then((res) => res.json())
          .then((results) => {
            if (!results || !results.length) {
              alert("No results found for that place.");
              return;
            }

            const r = results[0];
            const lat = parseFloat(r.lat);
            const lon = parseFloat(r.lon);

            state.lat = lat;
            state.lon = lon;

            const name = r.display_name.split(",")[0];
            const coordsText = `${lat.toFixed(3)}¬∞, ${lon.toFixed(3)}¬∞`;

            setLocationDisplay({
              labelMain: name,
              labelDetail: "Location chosen via search.",
              sourceLabel: "Manual search",
              sourceKind: "search",
              coordsText,
              shortLabel: name
            });

            updateLightPollution(lat, lon);
          })
          .catch((err) => {
            console.error("Search failed", err);
            alert("Search failed ‚Äì please try again or use GPS / IP.");
          })
          .finally(() => {
            searchButtonEl.disabled = false;
          });
      }

      function init() {
        updateFooterTime();
        kpInputEl.addEventListener("input", onKpChange);

        gpsButtonEl.addEventListener("click", () => {
          initLocationViaGps();
        });

        searchButtonEl.addEventListener("click", () => {
          const q = searchInputEl.value.trim();
          if (!q) return;
          geocodeSearch(q);
        });

        searchInputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const q = searchInputEl.value.trim();
            if (!q) return;
            geocodeSearch(q);
          }
        });

        // Start with IP fallback; GPS button lets user override
        useIpLocationFallback();
        onKpChange();
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
